module;
#include <algorithm>
#include <array>
#include <cstddef>
#include <cstdint>
#include <iterator>
#include <ranges>
#include <tuple>
#include <vector>

export module triple.ecs:query;
import triple.refl;
import triple.base;
import :entity;
import :archetype;
import :utils;

namespace triple::ecs {

export class GenericQuery {
    friend class World;

  public:
    class QueryInfo {
      public:
    };

    // class Iterator {
    //   public:
    //     Iterator(GenericQuery* q, size_t archetype_index, size_t
    //     entity_index) :
    //         m_query(q), m_archetype_index(archetype_index),
    //         m_entity_index(entity_index) {}

    //     refl::Ref get(const refl::Type& type) {
    //         Archetype* archetype = m_query->matched()[m_archetype_index];
    //         auto iter = std::ranges::find(m_query->components(), &type);
    //         if (iter == archetype->m_components.end()) {
    //             log::error("Iterator::get: type mismatch");
    //             return nullptr;
    //         }
    //         Entity entity = archetype->entities()[m_entity_index];
    //         return refl::Ref(archetype->get_component(entity, type), type);
    //     }

    //     template<class T>
    //     T& get() {
    //         return get(refl::type<T>()).value<T>();
    //     }

    //     bool next() {
    //         m_entity_index++;
    //         if (m_entity_index ==
    //             m_query->matched()[m_archetype_index]->size()) {
    //             m_entity_index = 0;
    //             m_archetype_index++;
    //         }
    //         return m_archetype_index != m_query->matched().size();
    //     }

    //     operator bool() const {
    //         return m_archetype_index != m_query->matched().size();
    //     }

    //   private:
    //     GenericQuery* m_query;
    //     size_t m_archetype_index;
    //     size_t m_entity_index;
    // };

  public:
    GenericQuery(ComponentVector components) : m_components(components) {
        std::ranges::sort(m_components);
        m_hash = TypeVectorHasher {}(m_components);
    }

    std::size_t hash() const { return m_hash; }

    bool matches(Archetype* archetype) {
        for (auto component : m_components) {
            if (std::ranges::find(archetype->components(), component) ==
                archetype->components().end()) {
                return false;
            }
        }
        return true;
    }

    void add_if_matches(Archetype* archetype) {
        if (matches(archetype) &&
            std::ranges::find(m_matched, archetype) == m_matched.end()) {
            m_matched.push_back(archetype);
        }
    }

    const std::vector<Archetype*>& matched() const { return m_matched; }

    const ComponentVector& components() const { return m_components; }

    // Iterator iter() { return Iterator(this, 0, 0); }

  protected:
    ComponentVector m_components;
    std::vector<Archetype*> m_matched;
    std::size_t m_hash;
};

export template<class... Args>
class Query {
  public:
    struct Iterator {
        using iterator_category = std::forward_iterator_tag;
        using difference_type = std::ptrdiff_t;
        using value_type = std::tuple<Args&...>;
        using pointer = value_type*;
        using reference = value_type&;

        Iterator(Query* q, size_t archetype_index, size_t entity_index) :
            m_query(q), m_archetype_index(archetype_index),
            m_entity_index(entity_index) {
            update_pointers();
        }

        template<class T>
        T& get() const {
            return *static_cast<T*>(m_archetype->get_component(
                m_archetype->entities()[m_entity_index],
                refl::type<T>()
            ));
        }

        Entity entity() const {
            return m_archetype->entities()[m_entity_index];
        }

        Archetype& archetype() const { return *m_archetype; }

        value_type operator*() const {
            return {*static_cast<Args*>(
                m_pointers[index_in_args<Args, Args...>()]
            )...};
        }

        Iterator& operator++() {
            m_entity_index++;
            [&]<size_t... ArgIdx>(std::index_sequence<ArgIdx...>) {
                ((m_pointers[ArgIdx] =
                      static_cast<char*>(m_pointers[ArgIdx]) + sizeof(Args)),
                 ...);
            }(std::make_index_sequence<sizeof...(Args)>());
            while (m_entity_index == m_archetype->size()) {
                m_entity_index = 0;
                m_archetype_index++;
                if (m_archetype_index == m_query->matched().size())
                    return *this;
                update_pointers();
            }
            return *this;
        }

        bool operator==(const Iterator& other) const {
            return m_query == other.m_query &&
                   m_archetype_index == other.m_archetype_index &&
                   m_entity_index == other.m_entity_index;
        }

        bool operator!=(const Iterator& other) const {
            return !(*this == other);
        }

      private:
        void update_pointers() {
            if (m_archetype_index != m_query->matched().size()) {
                m_archetype = m_query->matched()[m_archetype_index];
                m_pointers = {m_archetype->get_component(
                    m_archetype->get_column_index(refl::type<Args>()),
                    0
                )...};
            }
        }

        Query* m_query;
        size_t m_archetype_index;
        size_t m_entity_index;
        Archetype* m_archetype;
        std::array<void*, sizeof...(Args)> m_pointers;
    };

    Query(GenericQuery& q) : m_query(q) {
        // maybe check types
    }

    static size_t hash() {
        return TypeVectorHasher {}({&refl::type<Args>()...});
    }

    static ComponentVector components() { return {&refl::type<Args>()...}; }

    const std::vector<Archetype*>& matched() const { return m_query.matched(); }

    bool empty() const {
        return std::ranges::all_of(matched(), [](Archetype* archetype) {
            return archetype->size() == 0;
        });
    }

    Iterator iter() { return begin(); }

    Iterator begin() {
        size_t archetype_index = 0;
        while (archetype_index < matched().size() &&
               matched()[archetype_index]->size() == 0) {
            archetype_index++;
        }
        return Iterator {this, archetype_index, 0};
    }
    Iterator end() { return Iterator {this, matched().size(), 0}; }

  private:
    GenericQuery& m_query;
};

} // namespace triple::ecs

namespace std {
template<>
struct hash<triple::ecs::GenericQuery> {
    std::size_t operator()(const triple::ecs::GenericQuery& query) const {
        return query.hash();
    }
};
} // namespace std
