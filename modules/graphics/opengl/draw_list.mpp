module;
#include <glad/glad.h>

export module triple.graphics.opengl:draw_list;
import triple.graphics;
import triple.base;
import :utils;
import :shader;
import :texture2d;
import :framebuffer;
import :render_pipeline;
import :program;
import :buffer;

namespace triple::graphics::opengl {

export class DrawListOpenGL : public DrawList {
  public:
    virtual void begin(const RenderPassDescriptor& desc) {
        m_framebuffer = static_cast<FramebufferOpenGL*>(desc.framebuffer);
        glBindFramebuffer(GL_FRAMEBUFFER, m_framebuffer->handler());

        GLbitfield clear_mask = 0;
        if (desc.clear_color) {
            auto color = desc.clear_color_value;
            glClearColor(color.r, color.g, color.b, color.a);
            clear_mask |= GL_COLOR_BUFFER_BIT;
        }
        if (desc.clear_depth) {
            glClearDepth(desc.clear_depth_value);
            clear_mask |= GL_DEPTH_BUFFER_BIT;
        }
        if (clear_mask)
            glClear(clear_mask);
        opengl_check_error();
    }

    virtual void set_viewport(i32 x, i32 y, u32 w, u32 h) { glViewport(x, y, w, h); }

    virtual void bind_render_pipeline(const RenderPipeline* pipeline) {
        m_pipeline = static_cast<const RenderPipelineOpenGL*>(pipeline);

        auto program = static_cast<const ProgramOpenGL*>(m_pipeline->program());
        glUseProgram(program->handler());

        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

        opengl_check_error();
    }

    virtual void bind_vertex_buffer(const Buffer* buffer) {
        auto bufferGL = static_cast<const BufferOpenGL*>(buffer);

        glBindBuffer(GL_ARRAY_BUFFER, bufferGL->handler());

        const auto& attributes = m_pipeline->vertex_layout().attributes;
        for (const auto& attr : attributes) {
            glEnableVertexAttribArray(attr.location);
            glVertexAttribPointer(
                attr.location,
                convert_attribute_size(attr.format),
                convert_attribute_type(attr.format),
                attr.normalized,
                m_pipeline->vertex_layout().stride,
                reinterpret_cast<GLvoid*>((u64)attr.offset)
            );
            opengl_check_error();
        }
    }

    virtual void bind_texture(const Texture2D* texture) {
        auto textureGL = static_cast<const Texture2DOpenGL*>(texture);
        textureGL->apply(0);
        opengl_check_error();
    }

    virtual void draw(size_t start, size_t count) {
        glDrawArrays(convert_render_primitive(m_pipeline->render_primitive()), start, count);
        opengl_check_error();
    }

    virtual void end() {
        glBindFramebuffer(GL_READ_FRAMEBUFFER, m_framebuffer->handler());
        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
        GLint dims[4] = {0};
        glGetIntegerv(GL_VIEWPORT, dims);
        auto width = dims[2];
        auto height = dims[3];
        glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);
    }

  private:
    const RenderPipelineOpenGL* m_pipeline;
    FramebufferOpenGL* m_framebuffer;
};

} // namespace triple::graphics::opengl
